This is a TensorFlow implementation of several techniques described in the papers: Additionally, techniques are presented for semantic segmentation and multiple style transfer. The Neural Style algorithm synthesizes a pastiche by separating and combining the content of one image with the style of another image using convolutional neural networks (CNN). Below is an example of transferring the artistic style of The Starry Night onto a photograph of an African lion: Transferring the style of various artworks to the same content image produces qualitatively convincing results: Here we reproduce Figure 3 from the first paper, which renders a photograph of the Neckarfront in TÃ¼bingen, Germany in the style of 5 different iconic paintings The Shipwreck of the Minotaur, The Starry Night, Composition VII, The Scream, Seated Nude: The relative weight of the style and content can be controlled. Here we render with an increasing style weight applied to Red Canna: More than one style image can be used to blend multiple artistic styles. Top row (left to right): The Starry Night + The Scream, The Scream + Composition VII, Seated Nude + Composition VII Bottom row (left to right): Seated Nude + The Starry Night, Oversoul + Freshness of Cold, David Bowie + Skull When using multiple style images, the degree of blending between the images can be controlled. Top row (left to right): content image, .2 The Starry Night + .8 The Scream, .8 The Starry Night + .2 The Scream Bottom row (left to right): .2 Oversoul + .8 Freshness of Cold, .5 Oversoul + .5 Freshness of Cold, .8 Oversoul + .2 Freshness of Cold The color scheme of the original image can be preserved by including the flag . Colors are transferred using either the YUV, YCrCb, CIE L*a*b*, or CIE L*u*v* color spaces. Here we reproduce Figure 1 and Figure 2 in the third paper using luminance-only transfer: Left to right: content image, stylized image, stylized image with the original colors of the content image The algorithm is not constrained to artistic painting styles. It can also be applied to photographic textures to create pareidolic images. Style can be transferred to semantic segmentations in the content image. Multiple styles can be transferred to the foreground and background of the content image. Note: The masking is done during synthesis; not as a post-processing step. Animations can be rendered by applying the algorithm to each source frame. For the best results, the gradient descent is initialized with the previously stylized frame warped to the current frame according to the optical flow between the pair of frames. Loss functions for temporal consistency are used to penalize pixels excluding disoccluded regions and motion boundaries. Top row (left to right): source frames, ground-truth optical flow visualized Bottom row (left to right): disoccluded regions and motion boundaries, stylized frames The initialization of the gradient descent is controlled using for single images and or for video frames. White noise allows an arbitrary number of distinct images to be generated. Whereas, initializing with a fixed image always converges to the same output. Here we reproduce Figure 6 from the first paper: Top row (left to right): Initialized with the content image, the style image, white noise (RNG seed 1) Bottom row (left to right): Initialized with white noise (RNG seeds 2, 3, 4) The feature complexities and receptive field sizes increase down the CNN heirarchy. Here we reproduce Figure 3 from the original paper: Rows: increasing subsets of CNN layers; i.e. 'conv4_1' means using 'conv1_1', 'conv2_1', 'conv3_1', 'conv4_1'. Columns: alpha/beta ratio of the the content and style reconstruction (see Content / Style Tradeoff). Note: Paths to images should not contain the character to represent your home directory; you should instead use a relative path or the absolute path. To use multiple style images, pass a space-separated list of the image names and image weights like this: Note: When using you must have previously computed the backward and forward optical flow between the frames. See and By default, uses the NVIDIA cuDNN GPU backend for convolutions and L-BFGS for optimization. These produce better and faster results, but can consume a lot of memory. You can reduce memory usage with the following: All images were rendered on a machine with: The implementation is based on the projects: Artistic images were created by the modern artists: Artistic images were created by the popular historical artists: Bash shell scripts for testing were created by my brother Sheldon Smith. If you find this code useful for your research, please cite: