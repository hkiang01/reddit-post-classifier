This repository contains code accompanying the paper Recurrent Highway Networks (RHNs). RHNs are an extension of Long Short Term Memory Networks with forget gates to enable the learning of deep recurrent state transitions. We provide implementations in Tensorflow, Torch7 and Brainstorm libraries, and welcome additional implementations from the community. The recurrent state transition in typical recurrent networks is modeled with a single step non-linear function. This can be very inefficient in principle for modeling complicated transitions, requiring very large networks. Increased recurrence depth allows RHNs to model complex transitions more efficiently achieving substantially improved results. Moreover, using depth d in the recurrent state transition is much more powerful than stacking d recurrent layers. The figures below illustrate that if we consider the functions mapping one hidden state to another T time steps apart, its maximum depth scales as the product of d and T instead of the sum. Of course, in general RHNs can also be stacked to get the best of both worlds. The score (perplexity) of word-level language models on the Penn Treebank dataset dramatically improves as recurrence depth increases while keeping the model size fixed. WT refers to tying the input and output weights for regularization. This idea was independently developed by Inan and Khosravi and Press and Wolf. Recently, Inan et al. also posted a more detailed follow-up paper. *We used 1000 samples for MC dropout as done by Gal for LSTMs, but we've only evaluated the depth 5 model so far. Tensorflow code for RHNs is built by heavily extending the LSTM language modeling example provided in Tensorflow. It supports Variational RHNs as used in the paper, which use the same dropout mask at each time step and at all layers inside the recurrence. Note that this implementation uses the same dropout mask for both the H and T non-linear transforms in RHNs while the Torch7 implementation uses different dropout masks for different transformations. The Theano implementation can be configured either way. We recommend installing Tensorflow in a virtual environment. In addition to the usual Tensorflow dependencies, the code uses Sacred so you need to do: To reproduce SOTA results on enwik8 (Wikipedia), first download the dataset from http://mattmahoney.net/dc/enwik8.zip and unzip it into the directory, then run: This is a Sacred experiment, so you check the hyperparameter options using the command, e.g. Torch7 code is based on Yarin Gal's adaptation of Wojciech Zaremba's code implementing variational dropout. The main additions to Gal's code are the Recurrent Highway Network layer, the initial biasing of T-gate activations to facilitate learning and a few adjustments to other network parameters such as and dropout probabilities. We recommend installing Torch from the official website. To ensure the code runs some packages need to be installed: To run on the enwik8 dataset, first download and prepare the data (see data/README for details): Then you can train by running: The Theano code's configuration and usage is similar to that of the Tensorflow code. In this implementation two configuration options were added: As with the Tensorflow code, the SOTA results on Penn Treebank and on enwik8 (Wikipedia) can be reproduced: An RHN layer implementation is also provided in Brainstorm. This implementation does not use variational dropout. It can be used in a Brainstorm experiment by simply importing from brainstorm_rhn.py. If you use RHNs in your work, please cite us: